{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-hq-image",
  "type": "registry:hook",
  "title": "useHqImage",
  "description": "A hook for use-hq-image",
  "dependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "path": "delta/hooks/use-hq-image.ts",
      "content": "\"use client\"\n\nimport { useState, useCallback, useEffect, useRef } from \"react\"\n\nexport type HqImage = { url: string }\n\n// Create a global cache that persists between hook instances\n// This will store loaded images across component instances\nconst imageCache = new Map<string, HTMLImageElement>()\n\n/**\n * A hook that returns high-quality images from a curated collection\n * with silent retry functionality and image caching\n * @param initialIndex Optional specific index to use instead of random selection\n * @param maxRetries Maximum number of retries for failed images (default: 5)\n * @returns An object containing the selected image, functions to refresh it, and a method to get multiple random images\n */\nexport function useHqImage(initialIndex?: number, maxRetries: number = 5) {\n  // Track failed image URLs to avoid reusing them\n  const failedUrls = useRef<Set<string>>(new Set())\n\n  // Track retry attempts for current image\n  const retryCount = useRef<number>(0)\n\n  // Track retry attempts for grid images\n  const gridRetryCount = useRef<Map<string, number>>(new Map())\n\n  // Track loaded status for images\n  const loadedImages = useRef<Set<string>>(new Set())\n\n  // Function to preload an image and add it to the cache\n  const preloadImage = useCallback((url: string): Promise<HTMLImageElement> => {\n    // If image is already in cache, return it\n    if (imageCache.has(url)) {\n      return Promise.resolve(imageCache.get(url)!)\n    }\n\n    // Create a new promise to load the image\n    return new Promise((resolve, reject) => {\n      const img = new Image()\n\n      img.onload = () => {\n        // Add to cache on successful load\n        imageCache.set(url, img)\n        loadedImages.current.add(url)\n        resolve(img)\n      }\n\n      img.onerror = () => {\n        reject(new Error(`Failed to load image: ${url}`))\n      }\n\n      img.src = url\n    })\n  }, [])\n\n  // Get a random image from the collection, avoiding failed URLs\n  const getRandomImage = useCallback((): HqImage => {\n    // Filter out failed URLs if we have any\n    const availableImages = failedUrls.current.size > 0\n      ? exampleImages.filter(img => !failedUrls.current.has(img.url))\n      : exampleImages\n\n    // If we've exhausted all images, reset failed URLs and try again\n    if (availableImages.length === 0) {\n      console.warn('All images have failed to load. Resetting failed URLs list.')\n      failedUrls.current.clear()\n      return exampleImages[Math.floor(Math.random() * exampleImages.length)]\n    }\n\n    const randomIndex = Math.floor(Math.random() * availableImages.length)\n    const selectedImage = availableImages[randomIndex]\n\n    // Try to preload the image (don't await, let it load in background)\n    preloadImage(selectedImage.url).catch(() => {\n      // If preloading fails, it will be handled by the error handlers\n    })\n\n    return selectedImage\n  }, [preloadImage])\n\n  // Initialize state with either the specified image or a random one\n  const [image, setImage] = useState<HqImage>(() => {\n    if (initialIndex !== undefined && initialIndex >= 0 && initialIndex < exampleImages.length) {\n      const selectedImage = exampleImages[initialIndex]\n      // Try to preload the image (don't await, let it load in background)\n      preloadImage(selectedImage.url).catch(() => {\n        // If preloading fails, it will be handled by the error handlers\n      })\n      return selectedImage\n    }\n    return getRandomImage()\n  })\n\n  // Function to refresh the image with a new random one\n  const refreshImage = useCallback(() => {\n    // Reset retry count when manually refreshing\n    retryCount.current = 0\n    setImage(getRandomImage())\n  }, [getRandomImage])\n\n  // Function to handle image load errors and retry\n  const handleImageError = useCallback((imageUrl: string): HqImage => {\n    // Add to failed URLs set\n    failedUrls.current.add(imageUrl)\n\n    // Log warning\n    console.warn(`Image failed to load: ${imageUrl}. Trying another image.`)\n\n    // Get a new image\n    return getRandomImage()\n  }, [getRandomImage])\n\n  // New function to get multiple unique random images\n  const getRandomImages = useCallback((count: number): HqImage[] => {\n    // Reset grid retry tracking when getting new batch\n    gridRetryCount.current.clear()\n\n    // Ensure we don't request more images than available\n    const requestCount = Math.min(count, exampleImages.length)\n\n    // Create a copy of the images array to shuffle, filtering out known failed URLs\n    const availableImages = failedUrls.current.size > 0\n      ? exampleImages.filter(img => !failedUrls.current.has(img.url))\n      : exampleImages\n\n    const shuffled = [...availableImages]\n\n    // Fisher-Yates shuffle algorithm\n    for (let i = shuffled.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1))\n      ;[shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]\n    }\n\n    // Get the selected images\n    const selectedImages = shuffled.slice(0, requestCount)\n\n    // Preload all selected images in the background\n    selectedImages.forEach(img => {\n      preloadImage(img.url).catch(() => {\n        // If preloading fails, it will be handled by the error handlers\n      })\n    })\n\n    // Return the selected images\n    return selectedImages\n  }, [preloadImage])\n\n  // Function to retry a specific grid image\n  const retryGridImage = useCallback((imageUrl: string): HqImage => {\n    // Track retry count for this specific URL\n    const currentRetries = gridRetryCount.current.get(imageUrl) || 0\n\n    if (currentRetries < maxRetries) {\n      // Increment retry count\n      gridRetryCount.current.set(imageUrl, currentRetries + 1)\n      console.warn(`Grid image failed to load: ${imageUrl}. Retry ${currentRetries + 1}/${maxRetries}`)\n\n      // Get a new image\n      return getRandomImage()\n    } else {\n      // Max retries reached, mark as failed\n      failedUrls.current.add(imageUrl)\n      console.warn(`Grid image failed after ${maxRetries} retries: ${imageUrl}`)\n\n      // Get a new image\n      return getRandomImage()\n    }\n  }, [getRandomImage, maxRetries])\n\n  // Function to check if an image is cached\n  const isImageCached = useCallback((url: string): boolean => {\n    return imageCache.has(url)\n  }, [])\n\n  // Function to get an image from cache\n  const getImageFromCache = useCallback((url: string): HTMLImageElement | null => {\n    return imageCache.get(url) || null\n  }, [])\n\n  // Create a wrapped version of the hook's return value with retry and caching functionality\n  const hookWithRetry = {\n    // Original image with retry functionality\n    image,\n\n    // Original refresh function\n    refreshImage,\n\n    // Original get random images function\n    getRandomImages,\n\n    // All images\n    allImages: exampleImages,\n\n    // New functions for retry handling\n    handleImageError,\n    retryGridImage,\n\n    // Function to check if an image URL has failed\n    hasImageFailed: (url: string) => failedUrls.current.has(url),\n\n    // Function to reset all failed URLs\n    resetFailedImages: () => {\n      failedUrls.current.clear()\n      retryCount.current = 0\n      gridRetryCount.current.clear()\n      console.log('Reset all failed image tracking')\n    },\n\n    // Cache-related functions\n    preloadImage,\n    isImageCached,\n    getImageFromCache,\n\n    // Function to clear the image cache\n    clearImageCache: () => {\n      imageCache.clear()\n      loadedImages.current.clear()\n      console.log('Image cache cleared')\n    },\n\n    // Get cache stats\n    getCacheStats: () => ({\n      cacheSize: imageCache.size,\n      cachedUrls: Array.from(imageCache.keys())\n    })\n  }\n\n  return hookWithRetry\n}\n\n// Hardcoded image collection\nexport const exampleImages = [\n  {\n    url: \"https://images.unsplash.com/photo-1727341554370-80e0fe9ad082?q=80&w=2276&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\",\n  },\n  {\n    url: \"https://images.unsplash.com/photo-1640680608781-2e4199dd1579?q=80&w=3087&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\",\n  },\n  {\n    url: \"https://images.unsplash.com/photo-1726083085160-feeb4e1e5b00?q=80&w=3024&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\",\n  },\n  {\n    url: \"https://images.unsplash.com/photo-1562016600-ece13e8ba570?q=80&w=2838&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\",\n  },\n  {\n    url: \"https://images.unsplash.com/photo-1624344965199-ed40391d20f2?q=80&w=2960&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\",\n  },\n  {\n    url: \"https://images.unsplash.com/photo-1689553079282-45df1b35741b?q=80&w=3087&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\",\n  },\n  {\n    url: \"https://images.unsplash.com/photo-1721968317938-cf8c60fccd1a?q=80&w=2728&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\",\n  },\n  {\n    url: \"https://images.unsplash.com/photo-1677338354108-223e807fb1bd?q=80&w=3087&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\",\n  },\n  {\n    url: \"https://images.aiscribbles.com/34fe5695dbc942628e3cad9744e8ae13.png?v=60d084\",\n  },\n  {\n    url: \"https://images.unsplash.com/photo-1734189743286-a39af55f48c3\",\n  },\n  {\n    url: \"https://images.unsplash.com/photo-1733309544294-700e617cba60\",\n  },\n  {\n    url: \"https://images.unsplash.com/photo-1738916218012-4e580beae18e\",\n  },\n  {\n    url: \"https://images.unsplash.com/photo-1735905131227-88f4942d1d38\",\n  },\n  {\n    url: \"https://images.unsplash.com/photo-1734760418281-62c3f2279296\",\n  },\n  {\n    url: \"https://images.unsplash.com/photo-1741017162002-fac8e37509f9\",\n  },\n  {\n    url: \"https://images.unsplash.com/photo-1732905176274-ffdcffbeab41\",\n  },\n]\n",
      "type": "registry:hook",
      "target": "delta/hooks/use-hq-image.ts"
    }
  ]
}